## Spring DI (Dependency Injetction, 의존성 주입)

의존성 주입이란?

```
어떤 객체가 사용하는 의존객체를 직접 만들어 사용하는게 아니라, 외부로부터 주입받아 사용하는 방법
(new 연산자를 이용해서 객체를 생성하는 것 대신 스프링 컨테이너에서 객체를 생성하는 방식)
```

- _의존성 주입을 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다는 장점이 있다_

> 예를 들어, **B클래스 내에서 A클래스의 인스턴스 a를 생성하거나 A클래스의 멤버들을 직접적으로 사용**한다면, `B클래스는 A클래스에 의존`한다고 볼 수 있다

---

### Spring에서의 의존성 주입 방법

- 생성자 주입
- 필드 주입
- 수정자 주입(setter)

#### 덧붙여 setter을 지양해야 하는 이유는 다음과 같다

- setter(수정자)을 사용하여 필드의 변경의 가능성을 열어두면, 다른 곳에서 임의로 객체를 변경할 수 있기 때문에 에러가 발생할 위험이 높음

- 또한 객체의 불변을 보장해야하는 클래스에서 수정자 사용시 캡슐화가 깨져버리게 되고, 정보은닉을 고수할 수 없게되기 때문에 사용을 지양해야함

---

### 생성자주입

```
생성자 주입이란 객체간의 의존성을 객체생성 과정에서 생성자를 통해 주입하는 방식을 말한다
```

-> Spring에서는 다양한 의존성 주입 방법들중 생성자 주입을 사용하는것을 권장하는데, 그 이유는 다음과 같다

`객체 불변성 확보`

객체의 상태가 생성 후에 변하지 않도록 하는 것을 의미

> 객체의 생성자는 객체 생성 시 1회만 호출된다는 게 보장되는 특징이 있기 때문에, 이를 통해 의존성 주입을 한다면 객체가 사용되는 동안 해당 의존성이 변경되지 않는 안정성을 보장받을 수 있다

`테스트에 용이`

> 생성자 주입이 아닌 의존성 주입을 사용하여 테스트 코드를 작성하게되면, 의존관계 주입이 정상적으로 되지 않아 null이 주입되어 NullPointError가 발생하는 문제가 생긴다

`순환참조 에러 방지`

순환참조 에러란 필드 또는 수정자 주입 방식을 사용했을때  
A객체가 B객체를 참조하고, B객체가 A객체를 서로 참조하고 있을 때 발생하는 에러를 말함

> 하지만 같은 코드에서 생성자 주입 방식을 사용한다면 애플리케이션은 실행되지 않고 예외가 발생하여 문제를 알 수 있다
